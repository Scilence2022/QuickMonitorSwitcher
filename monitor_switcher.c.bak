#include <ApplicationServices/ApplicationServices.h>
#include <Carbon/Carbon.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>
#include <unistd.h>

#define LEFT_ARROW_KEYCODE  0x7B
#define RIGHT_ARROW_KEYCODE 0x7C

// Add Hotkey struct and global instances for all actions
typedef struct {
    CGEventFlags required;
    CGEventFlags forbidden;
    CGKeyCode keycode;
    char name[32];
} Hotkey;

static Hotkey hkPrevDisplay = { kCGEventFlagMaskCommand,
    kCGEventFlagMaskControl|kCGEventFlagMaskShift|kCGEventFlagMaskAlternate,
    LEFT_ARROW_KEYCODE, "Switch Previous Display" };
static Hotkey hkNextDisplay = { kCGEventFlagMaskControl,
    kCGEventFlagMaskShift|kCGEventFlagMaskAlternate|kCGEventFlagMaskCommand,
    0x31, "Switch Next Display" };
static Hotkey hkExitApp = { kCGEventFlagMaskControl|kCGEventFlagMaskAlternate|kCGEventFlagMaskCommand,
    kCGEventFlagMaskShift,
    0x0C, "Exit Application" };
static Hotkey hkShowConfig = { kCGEventFlagMaskControl|kCGEventFlagMaskAlternate|kCGEventFlagMaskCommand,
    kCGEventFlagMaskShift,
    0x28, "Show Configuration" };

// Prototypes for config handling
bool checkHotkey(const Hotkey *hk, CGEventFlags flags, CGKeyCode keycode);
void loadHotkeysFromConfig(void);
void showConfigWindow(void);
bool parseHotkeyString(const char *str, Hotkey *hk);

// Function to display a notification with cursor position
void notifyCursorPosition() {
    CGEventRef tempEvent = CGEventCreate(NULL);
    if (!tempEvent) return;
    CGPoint cursorPos = CGEventGetLocation(tempEvent);
    CFRelease(tempEvent);

    char notificationCmd[256];
    // Use snprintf to prevent buffer overflows
    snprintf(notificationCmd, sizeof(notificationCmd),
             "osascript -e 'display notification \"Cursor at X: %.0f, Y: %.0f\" with title \"QuickMonitorSwitcher\"' &> /dev/null",
             cursorPos.x, cursorPos.y);
    system(notificationCmd);
}

// Switch cursor position by one display in the given direction (-1 = left, +1 = right)
void switchDisplay(int direction) {
    // Get list of active displays
    uint32_t maxDisplays = 16;
    uint32_t displayCount = 0;
    CGDirectDisplayID displays[16];
    CGError err = CGGetActiveDisplayList(maxDisplays, displays, &displayCount);
    if (err != kCGErrorSuccess || displayCount < 2) {
        return;
    }

    // Get current cursor position
    CGEventRef mouseEvent = CGEventCreate(NULL);
    CGPoint currentPos = CGEventGetLocation(mouseEvent);
    CFRelease(mouseEvent);

    // Find which display the cursor is currently on
    int currentIndex = 0;
    CGRect currentBounds = CGDisplayBounds(displays[0]);
    for (uint32_t i = 0; i < displayCount; ++i) {
        CGRect bounds = CGDisplayBounds(displays[i]);
        if (CGRectContainsPoint(bounds, currentPos)) {
            currentIndex = i;
            currentBounds = bounds;
            break;
        }
    }

    // Calculate the next display index
    int newIndex = (currentIndex + direction + displayCount) % displayCount;
    CGRect newBounds = CGDisplayBounds(displays[newIndex]);

    // Compute proportional position within the current display
    double fracX = 0.0, fracY = 0.0;
    if (currentBounds.size.width > 0)
        fracX = (currentPos.x - currentBounds.origin.x) / currentBounds.size.width;
    if (currentBounds.size.height > 0)
        fracY = (currentPos.y - currentBounds.origin.y) / currentBounds.size.height;

    // Compute new absolute position proportionally on the target display
    double newX = newBounds.origin.x + fracX * newBounds.size.width;
    double newY = newBounds.origin.y + fracY * newBounds.size.height;

    // Clamp within the target display
    if (newX < newBounds.origin.x) newX = newBounds.origin.x;
    if (newX > newBounds.origin.x + newBounds.size.width) newX = newBounds.origin.x + newBounds.size.width;
    if (newY < newBounds.origin.y) newY = newBounds.origin.y;
    if (newY > newBounds.origin.y + newBounds.size.height) newY = newBounds.origin.y + newBounds.size.height;

    // Warp the cursor
    CGWarpMouseCursorPosition(CGPointMake(newX, newY));
    CGAssociateMouseAndMouseCursorPosition(true);

    notifyCursorPosition(); // Notify cursor position after switching
}

// Callback for keyboard events
CGEventRef eventTapCallback(CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *userInfo) {
    if (type != kCGEventKeyDown) {
        return event;
    }

    CGKeyCode keyCode = (CGKeyCode)CGEventGetIntegerValueField(event, kCGKeyboardEventKeycode);
    CGEventFlags flags = CGEventGetFlags(event);

    // Dynamic hotkey handling
    if (checkHotkey(&hkShowConfig, flags, keyCode)) {
        showConfigWindow();
        return NULL;
    }
    if (checkHotkey(&hkExitApp,     flags, keyCode)) {
        CFRunLoopStop(CFRunLoopGetCurrent());
        return NULL;
    }
    if (checkHotkey(&hkPrevDisplay, flags, keyCode)) {
        switchDisplay(-1);
        return NULL;
    }
    if (checkHotkey(&hkNextDisplay, flags, keyCode)) {
        switchDisplay(1);
        return NULL;
    }

    return event;
}

int main(void) {
    // Create an event tap to capture keydown events
    CGEventMask mask = CGEventMaskBit(kCGEventKeyDown);
    CFMachPortRef eventTap = CGEventTapCreate(
        kCGSessionEventTap,
        kCGHeadInsertEventTap,
        kCGEventTapOptionDefault,
        mask,
        eventTapCallback,
        NULL
    );

    if (!eventTap) {
        fprintf(stderr, "Failed to create event tap.\n");
        return EXIT_FAILURE;
    }

    // Create a run loop source and add to the current run loop
    CFRunLoopSourceRef runLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventTap, 0);
    CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, kCFRunLoopCommonModes);
    CGEventTapEnable(eventTap, true);

    // Run the loop
    CFRunLoopRun();

    // Cleanup (unreachable in this simple program)
    CFRelease(runLoopSource);
    CFRelease(eventTap);

    loadHotkeysFromConfig();

    return EXIT_SUCCESS;
}

// After notifyCursorPosition(), insert config functions
bool checkHotkey(const Hotkey *hk, CGEventFlags flags, CGKeyCode keycode) {
    if ((flags & hk->required) != hk->required) return false;
    if (flags & hk->forbidden) return false;
    return keycode == hk->keycode;
}

void loadHotkeysFromConfig(void) {
    char *home = getenv("HOME");
    if (!home) return;
    char path[PATH_MAX];
    snprintf(path, sizeof(path), "%s/.quickmonitorswitcher.conf", home);
    if (access(path, R_OK) != 0) return;
    FILE *f = fopen(path, "r");
    if (!f) return;
    char line[256];
    while (fgets(line, sizeof(line), f)) {
        char *eq = strchr(line, '=');
        if (!eq) continue;
        *eq = '\0';
        char *key = line;
        char *value = eq + 1;
        value[strcspn(value, "\r\n")] = '\0';
        if (strcmp(key, "switchPrev") == 0) parseHotkeyString(value, &hkPrevDisplay);
        else if (strcmp(key, "switchNext") == 0) parseHotkeyString(value, &hkNextDisplay);
        else if (strcmp(key, "exitApp") == 0) parseHotkeyString(value, &hkExitApp);
        else if (strcmp(key, "showConfig") == 0) parseHotkeyString(value, &hkShowConfig);
    }
    fclose(f);
}

void showConfigWindow(void) {
    const char *script =
        "osascript << 'END'\n"
        "set home to POSIX path of (path to home folder)\n"
        "set cfg to home & \".quickmonitorswitcher.conf\"\n"
        "try\n"
        "  set txt to paragraphs of (read POSIX file cfg)\n"
        "on error\n"
        "  set txt to {\"switchPrev=Command+Left\",\"switchNext=Control+Space\",\"exitApp=Control+Option+Command+Q\",\"showConfig=Control+Option+Command+K\"}\n"
        "end try\n"
        "set dialogText to \"Current Hotkeys:\" & return & (txt as string)\n"
        "set choice to button returned of (display dialog dialogText buttons {\"Close\",\"Modify\"} default button \"Close\")\n"
        "if choice is \"Modify\" then\n"
        "  set newPrev to text returned of (display dialog \"Switch Previous Display:\" default answer item 1 of txt)\n"
        "  set newNext to text returned of (display dialog \"Switch Next Display:\" default answer item 2 of txt)\n"
        "  set newExit to text returned of (display dialog \"Exit Application:\" default answer item 3 of txt)\n"
        "  set newShow to text returned of (display dialog \"Show Configuration:\" default answer item 4 of txt)\n"
        "  do shell script \"printf 'switchPrev=%s\\nswitchNext=%s\\nexitApp=%s\\nshowConfig=%s\\n' \" & quoted form of newPrev & \" \" & quoted form of newNext & \" \" & quoted form of newExit & \" \" & quoted form of newShow & \" > \" & quoted form of cfg\n"
        "  display notification \"Hotkeys updated\" with title \"QuickMonitorSwitcher\"\n"
        "end if\n"
        "END";
    system(script);
    loadHotkeysFromConfig();
}

bool parseHotkeyString(const char *str, Hotkey *hk) {
    CGEventFlags req = 0;
    if (strstr(str, "Control")||strstr(str, "control")) req |= kCGEventFlagMaskControl;
    if (strstr(str, "Shift")||strstr(str, "shift")) req |= kCGEventFlagMaskShift;
    if (strstr(str, "Option")||strstr(str, "option")||strstr(str, "Alt")||strstr(str, "alt")) req |= kCGEventFlagMaskAlternate;
    if (strstr(str, "Command")||strstr(str, "command")||strstr(str, "Cmd")||strstr(str, "cmd")) req |= kCGEventFlagMaskCommand;
    CGKeyCode kc = 0;
    if (strstr(str, "Left")||strstr(str, "left")) kc = LEFT_ARROW_KEYCODE;
    else if (strstr(str, "Right")||strstr(str, "right")) kc = RIGHT_ARROW_KEYCODE;
    else if (strstr(str, "Space")||strstr(str, "space")) kc = 0x31;
    else return false;
    hk->required = req;
    hk->forbidden = (kCGEventFlagMaskControl|kCGEventFlagMaskShift|kCGEventFlagMaskAlternate|kCGEventFlagMaskCommand) & ~req;
    hk->keycode = kc;
    return true;
}